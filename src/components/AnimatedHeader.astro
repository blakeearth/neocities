---
interface Props {
  title: string;
  pattern?: string;
  height?: string;
  mobileHeight?: string;
  border?: boolean;
  marginBottom?: string;
}

const {
  title = '',
  pattern,
  height = '300px',
  mobileHeight = '200px',
  border = true,
  marginBottom = '1rem'
} = Astro.props;

// Randomly select one of the three patterns at build time if not specified
const patterns = [
  'animated-pattern.svg',
  'animated-pattern-2.svg',
  'animated-pattern-3.svg'
];

// Use a simple prime-based distribution for more equal pattern selection
const stringToIndex = (str: string, arrayLength: number) => {
  if (!str) return 0;

  // Use character codes with prime multipliers for better distribution
  let sum = 0;
  const primes = [31, 37, 41, 43, 47, 53, 59, 61, 67, 71];

  for (let i = 0; i < str.length; i++) {
    sum += str.charCodeAt(i) * primes[i % primes.length];
  }

  return sum % arrayLength;
};

const selectedPattern = pattern || patterns[stringToIndex(title, patterns.length)];
const headerId = `header-${Math.random().toString(36).substr(2, 9)}`;

---

{title && (
  <div id={headerId} class="animated-header" style={`height: ${height}; margin-bottom: ${marginBottom}; ${border ? '' : 'border: none;'}`}>
    <object
      data={`/${selectedPattern}`}
      type="image/svg+xml"
      aria-label={title}
      class="pattern-svg"
    >
      <img src={`/${selectedPattern}`} alt={title} />
    </object>
    <div class="header-title">{title}</div>
  </div>
)}

<style define:vars={{ mobileHeight }}>
  .animated-header {
    position: relative;
    width: 100%;
    overflow: hidden;
    border: 0.2vh solid var(--border);
  }

  .pattern-svg {
    width: 100%;
    height: 100%;
    display: block;
  }

  .header-title {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-family: 'Abril Fatface', Georgia, serif;
    color: #363636;
    text-align: center;
    margin: 0;
    z-index: 10;
    max-width: 90%;
    line-height: 1.2;
    white-space: pre-wrap;
    background: #fff8ea;
    padding: 0.5rem 1rem;
    border: 0.2vh solid black;
  }

  @media (max-width: 768px) {
    .animated-header {
      height: var(--mobileHeight) !important;
    }
  }
</style>

<script define:vars={{ headerId }}>
  const resizeText = () => {
    const container = document.getElementById(headerId);
    const textEl = container?.querySelector('.header-title');

    if (!container || !textEl) return;

    const containerWidth = container.offsetWidth;
    const containerHeight = container.offsetHeight;

    // Get padding and border values
    const computedStyle = window.getComputedStyle(textEl);
    const paddingTop = parseFloat(computedStyle.paddingTop);
    const paddingBottom = parseFloat(computedStyle.paddingBottom);
    const borderTop = parseFloat(computedStyle.borderTopWidth);
    const borderBottom = parseFloat(computedStyle.borderBottomWidth);
    const verticalExtra = paddingTop + paddingBottom + borderTop + borderBottom;

    // Start with a larger font size
    let fontSize = containerWidth * 0.15;
    textEl.style.fontSize = fontSize + 'px';

    // Max height should account for the box chrome
    const maxHeight = containerHeight * 0.4;

    // Use scrollHeight to measure just the content, then add padding/border
    while ((textEl.scrollHeight + verticalExtra) > maxHeight && fontSize > 20) {
      fontSize -= 2;
      textEl.style.fontSize = fontSize + 'px';
    }
  };

  window.addEventListener('resize', resizeText);
  window.addEventListener('load', resizeText);
  resizeText();
</script>
